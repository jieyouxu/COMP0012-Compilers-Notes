\section{Semantic Analysis}

\subsection{Overview}

\begin{figure}[H]
    \centering
    \fbox{
    \begin{tikzpicture}
        \node [phantomblock]                            (start)     { \phantom{} };
        \node [block, below=1em of start]               (lexer)     {Lexical Analysis};
        \node [phantomblock, right=0.5em of lexer]                  {Regular Language};
        \node [block, below=1em of lexer]               (parser)    {Syntax Analysis};
        \node [phantomblock, right=0.5em of parser]                 {Context-Free Language};
        \node [block, below=1em of parser]              (semantic)  {Semantic Analysis};
        \node [phantomblock, right=0.5em of semantic]               {Contextual Language};
        \node [phantomblock, below=1em of semantic]     (end)       {};
        \draw [->] (start)      -- (lexer);
        \draw [->] (lexer)      -- (parser);
        \draw [->] (parser)     -- (semantic);
        \draw [->] (semantic)   -- (end);
    \end{tikzpicture}
    }
    \caption{Languages used for different phases}
    \label{fig:language-in-different-phases}
\end{figure}

\begin{remark}
    Up to this point, recall that
    \begin{itemize}
        \item \textit{Lexers} accept \textit{regular} grammar (\textit{Regex}).
        \item \textit{Parsers} accept \textit{context-free} grammar (\textit{CFG}).
        \item But programs are \textit{not context-free}.
    \end{itemize}
    
    That is,
    \begin{itemize}
        \item Programs which are \textit{syntactically correct} are indeed \textit{context-free}.
        \item But being \textit{syntactically correct} does not guarantee that a program can correctly compile -- the program must also be \textit{semantically correct}.
    \end{itemize}
    
    Hence, there exists an important distinction between \textit{Context-Free Grammars} (CFG) and \textit{Context-Sensitive Grammar} (CSG):
    
    \begin{tabular}{@{} |p{0.8\textwidth}}
        The \textit{context} is \textit{not} retained in \textit{Context-Free Grammar}, allowing programs that are \textit{syntactically correct} but make no \textit{semantic} sense. Additionally, the \textit{scope} of variables are not checked.
    \end{tabular}
\end{remark}

\begin{example}
    For example, given the short method
    \begin{figure}[H]
        \centering
        \begin{minted}{java}
            public void methodOne()
            {
                int x = 2;
                System.out.println(x.getDate());
                y++;
                int y;
                return x;
            }
        \end{minted}
        \caption{A program that is synatically correct but semantically wrong}
        \label{prog:syntactically-correct-semantically-wrong}
    \end{figure}
    
    The program is syntactically valid. However, there are multiple semantic errors:
    \begin{itemize}
        \item \texttt{x} is an integer, but an attempt was made to call \texttt{getDate()} on \texttt{x}.
        \item \texttt{y} is used before being declared.
        \item \texttt{methodOne} is declared to have no return value. However, \texttt{x} is returned in the last statement.
    \end{itemize}
\end{example}

\subsection{Context-Sensitive Grammar}

\begin{definition}[Context-Sensitive Grammar (CSG)]
    The \textit{Context-Sensitive Grammar} $G$ can be described by the 4-tuple
    \begin{equation}
        G = \langle
            \mathcal{N},
            \mathcal{T},
            \mathcal{R},
            S
        \rangle
    \end{equation}
    
    Where
    \begin{enumerate}
        \item \textbf{Non-terminals}: $\mathcal{N}$.
        \item \textbf{Terminals}: $\mathcal{T}$.
        \item \textbf{Production Rules}: $\mathcal{R}$.
        \item \textbf{Start Symbol}: $S$.
    \end{enumerate}
    
    The \textit{context-sensitive} property requires that
    \begin{equation}
        \Forall r \in \mathcal{R} \colon r = \alpha A \beta \to \alpha \gamma \beta
    \end{equation}
    
    That each production rule are of such form, where
    \begin{itemize}
        \item $A \in \mathcal{N}$ is a \textit{non-terminal}.
        \item $\alpha, \beta \in (\mathcal{N} \cup \mathcal{T})^\ast$ are strings of \textit{non-terminals} and \textit{terminals}.
        \item $\gamma \in (\mathcal{N} \cup \mathcal{T})^+$ is a \textit{non-empty} string of \textit{non-terminals} and \textit{terminals}.
        \begin{equation}
            \gamma \ne \emptyset
        \end{equation}
    \end{itemize}
\end{definition}

\subsection{Semantic Analysis}

Check outside the grammar for contextual correctness instead of trying to implement constraints within the language, for aspects such as
\begin{itemize}
    \item Undefined variables.
    \item Type errors.
    \item Scope errors.
    \item Duplicate definitions.
    \item Inheritance relationships.
\end{itemize}

\subsubsection{Contextual Constraints}

Important \textit{contextual constraints} include
\begin{enumerate}[itemsep=4pt, parsep=4pt, topsep=8pt, partopsep=4pt]
    \item \textbf{Scoping} rules:
        Checking area of effect of declarations.
    \item \textbf{Typing} rules: 
        Checking expressions have valid types.
\end{enumerate}

\subsubsection{Semantic Analysis Sub-phases}

Note that this list is \textit{non-exhaustive}.

\begin{itemize}[itemsep=4pt, parsep=4pt, topsep=8pt, partopsep=4pt]
    \item \textbf{Name Resolution}:
        Apply scoping rules to correspond identifier to declaration.
    \item \textbf{Type Checking}:
        Apply typing rules to infer type of expressions, and verify that the inferred type is compatible with the expected type.
\end{itemize}

\subsection{Scoping Rules}

\begin{definition}[Declaration]
    A \textit{declaration} associates information with an \textit{identifier}.
    
    There are two types of declarations:
    \begin{itemize}[itemsep=4pt, parsep=4pt, topsep=8pt, partopsep=4pt]
        \item \textbf{Explicit Declaration}. (In Java) 
            \begin{minted}{java}
                int i;
            \end{minted}
        \item \textbf{Implicit Declaration}. (In Fortran)
            \begin{minted}{fortran}
                    i;
            \end{minted}
            In Fortran, some identifiers \texttt{i}, \texttt{j}, ..., \texttt{n} are implicitly assumed to be integers, unless this feature is turned off.
    \end{itemize}
    
    It is possible for the same identifier to have independent declarations in different parts of a program, differentiating via \textit{scoping rules}.
\end{definition}

\begin{definition}[Scoping Rules]
    \textit{Scoping rules} define which declaration an identifier resolves to in each part of the program.
\end{definition}

\begin{definition}[Scope]
    The \textit{scope} of a declaration is the part of the program for which the declaration applies to.
\end{definition}

\subsubsection{Binding}

\begin{definition}[Binding]
    A \textit{binding} is the association between an identifier and the thing it represents.
\end{definition}

\begin{example}
    Given the Java method
    \begin{figure}[H]
        \centering
        \begin{minted}{java}
        public boolean foo(int n, int m) {
            boolean tmp;
            if (n<m) tmp = true;
            else tmp = false;
            return tmp;
        }
        \end{minted}
        \caption{A Java method}
        \label{prog:example-java-binding}
    \end{figure}
    
    Then its binding $\sigma_{\texttt{foo}}$ is
    \begin{equation}
        \sigma_{\texttt{foo}} = \left\lbrace
            \texttt{foo} \mapsto \texttt{int} \times \texttt{int} \to \texttt{boolean},
            \texttt{n} \mapsto \texttt{int},
            \texttt{m} \mapsto \texttt{int},
            \texttt{tmp} \mapsto \texttt{bool}
        \right\rbrace
    \end{equation}
\end{example}

\subsubsection{Static Scope}

\begin{definition}[Static Scope (Lexical Scope)]
    \textit{Static scope} is when scoping information is available at \textit{compile time} -- the scoping information is available within the source code.
    
    Usually, the \textit{most recent encounter} binds.
\end{definition}

\begin{definition}[Static Scope Design]
    Two \textit{static scope} designs exist:
    \begin{enumerate}
        \item Global.
        \item Local to function.
    \end{enumerate}
    
    Allowing nested functions introduce further complications as each nested function can begin a new scope.
\end{definition}

\begin{definition}[Closest Nested Scope Rule]
    The \textit{Closest Nested Scope} rule is defined as follows
    \begin{itemize}
        \item An identifier introduced in a declaration is known
        \begin{itemize}
            \item in the scope where the identifier is declared in, or
            \item in each internal scope that is nested after the declaration,
            \item \textit{unless} it is hidden by another declaration of the same identifier in one or more of the nested scope (known as \enquote{\textit{name shadowing}}).
        \end{itemize}
    \end{itemize}
\end{definition}

\begin{example}
    In the code fragment
    \begin{figure}[H]
        \centering
        \begin{minted}{javascript}
let x = 4;                  // Outermost scope L1
if (x > 0)
{                           // Inner scope L2
    let x = 3;              // L2's x shadows / hides x from L1
    if (x > 1)
    {                       // Innermost scope L3
        x = x + 1;          // L3's x modifies x from L2
        print(x)            // => 4
    }
    
    print(x);               // => 4 because L2's x modified in L3
}       
print(x);                   // => 4 L1's x
        \end{minted}
        \caption{Closest nested scope in effect}
        \label{prog:closest-nested-scope-rule}
    \end{figure}
\end{example}

\begin{definition}[Hole]
    A \textit{hole} in the scope of a binding occurs when the declaration of an identifier is \textit{hidden} or \textit{shadowed} by a nested declaration of the same identifier.
    
    In figure \ref{prog:closest-nested-scope-rule}, binding of \texttt{x} in $L_1$ is hidden by the declaration of the same name in the nested scope $L_2$.
\end{definition}

\begin{definition}[Qualifier]
    Some programming languages allow references to declarations in outer scopes that are shadowed by providing \textit{qualifiers} or \textit{scope resolution operators}.
\end{definition}

\begin{example}
    The \textit{scope resolution operator} $::$ is provided in C++
    \begin{figure}[H]
        \centering
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{minted}{c++}
#include <iostream>
int main(void)
{
    int cout = 42;
    cout << cout;
}
            \end{minted}
        \end{subfigure}
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{minted}{c++}
#include <iostream>
int main(void)
{
    int cout = 42;
    std::cout << cout;
}
            \end{minted}
        \end{subfigure}
        \caption{Scope resolution operator in C++}
        \label{fig:cpp-scope-resolution-operator}
    \end{figure}
\end{example}

\subsubsection{Dynamic Scope}

\begin{definition}[Dynamic Scope]
    \textit{Dynamic scope} refers to binding that is determined at run-time, depending on the flow of execution.
    \begin{itemize}
        \item Most recent declaration takes precedence.
        \item Binding expires when execution flow leaves lexical scope.
    \end{itemize}
    
    Generally execution flow cannot be predicted at compile time and so dynamic scope is usually implemented within \textit{interpreted} languages.
\end{definition}

\begin{remark}
    TODO
\end{remark}

% TODO
