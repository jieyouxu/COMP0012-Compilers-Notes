\section{Syntactic Analysis}

The language used in \textit{Syntactic Analysis} is the \textit{Context-Free Grammar} (CFG). Sometimes \textit{Parsing Expression Grammar} (PEG) is also used, but PEG is not covered in this course.

\subsection{Context-Free Grammar}

\begin{definition}[Context-Free Grammar (CFG)]
    A \textit{Context-Free Grammar} (CFG) $G$ can be described by the 4-tuple
    \begin{equation}
        G = \langle
            \mathcal{N},
            \mathcal{T},
            S,
            \mathcal{R}
        \rangle
    \end{equation}
    
    Where
    \begin{enumerate}
        \item \textbf{Non-terminals}: $\mathcal{N}$ is the finite set of \textit{non-terminals} (uppercase by convention).
        \item \textbf{Terminals}: $\mathcal{T}$ is the finite set of \textit{terminals} (lowercase by convention).
        \item \textbf{Start Symbol}: $S \in \mathcal{T}$ is the \textit{start} symbol.
        \item \textbf{Production Rules}: $\mathcal{R} \coloneqq \mathcal{N} \to (\mathcal{N} \cup \mathcal{T})^\ast$ is the set of finite relations, termed \textit{productions} or \textit{rules} of the grammar.
    \end{enumerate}
\end{definition}

\begin{remark}
    By convention,
    \begin{itemize}
        \item Nonterminals are written in uppercase.
        \item Terminals are either punctuation characters or written in lowercase.
        \item Start symbol is the left-hand side non-terminal of the first product.
    \end{itemize}
\end{remark}

\begin{example}
    A \textit{production}
    \begin{equation*}
        X \to Y_1 \cdots Y_n
    \end{equation*}
    Means that the non-terminal $X$ can be \textit{replaced} by $Y_1 \cdots Y_n$. Equivalently, the production right-hand side $Y_1 \cdots Y_n$ is \textit{produced} by $X$.
\end{example}

\subsubsection{Language of a Context-Free Grammar}

\begin{definition}[Language of a Context-Free Grammar]
    Given context-free grammar $G$ with the start symbol $S$, the \textit{language} of $G$ is
    \begin{equation}
        L(G) \coloneqq \left\lbrace a_1 \cdots a_n \mid S \xrightarrow{\ast} a_1 \cdots a_n, a_i \in \mathcal{T} \right\rbrace
    \end{equation}
    
    That is, $L(G)$ is the set of all strings of \textit{terminals} for which the grammar $G$ can generate in zero or more steps.
\end{definition}

\subsubsection{Terminals}

\begin{definition}[Terminals]
    Characters in the input alphabet $\mathcal{T}$ are called \textit{terminals} because there does not exist any production rules which can replace them.
    
    That is, \textit{terminals} only appear in the \textit{right-hand side} of any production rule.
\end{definition}

\begin{remark}
    If terminals are generated by any replacement steps, then they are \textit{permanent}.
    
    \textit{Terminals} are often \textit{lexemes} in the language. For example, the terminal \texttt{void} is a keyword lexeme in the C language.
\end{remark}

\subsection{Right Regular Grammar}

\begin{definition}[Right-regular Grammar]
    A \textit{Right-regular Grammar} $G$ is the 4-tuple
    \begin{equation}
        G = \langle
            \mathcal{N},
            \mathcal{T},
            S,
            \mathcal{R}
        \rangle
    \end{equation}
    
    And also satisfying three additional \textit{constraints}; given $A, B \in \mathcal{N}$ and $a \in \mathcal{T}$, and given $B$ is \textit{right-regular},
    \begin{enumerate}
        \item $A \to a$
        \item $A \to aB$
        \item $A \to \epsilon$
    \end{enumerate}
\end{definition}

\begin{remark}
    Note that a \textit{Left-regular Grammar} has the above definition with only one difference, in the second constraint; given $A, B \in \mathcal{N}$ and $B$ is \textit{left-regular},
    \begin{equation}
        A \to Ba
    \end{equation}

    If left and right rules are mixed together, a linear grammar is generated which is context-free.
\end{remark}

\subsubsection{Derivations}

\begin{definition}[Derivation]
    A \textit{derivation} is a sequence of \textit{sential forms} resulting from repeated applications of some \textit{production rule} beginning from $S$, replacing \textit{non-terminals} with their respective \textit{productions}.
\end{definition}

\begin{example}
    For instance,
    \begin{align*}
        S &\to X_1 \cdots X_a \cdots X_b \cdots \\
          &\to X_1 \cdots Y_c \cdots X_b \cdots \\
          &\to \cdots \\
          &\to Y_1 \cdots Y_m \\
          &\to \cdots \\
          &\to \alpha_1 \cdots \alpha_n \\
    \end{align*}
    
    The intermediate strings with mixed terminals and non-terminals are the \textit{sentential forms}.
    
    The last derivation with $S \xRightarrow{\ast} \alpha_1 \cdots \alpha_n$ with each $\alpha_1, \dots, \alpha_n \in \mathcal{T}$ being terminals is called a \textit{sentence}.
\end{example}

\begin{definition}[Sentential Form]
    A \textit{sentential form} $\alpha$ refers to the \textit{start symbol} $S$ or any strings of \textit{terminals} and \textit{non-terminals} $(\mathcal{N} \cup \mathcal{T})^\ast$ that can be \textit{derived} from $S$.
    \begin{equation}
        \alpha = (\mathcal{N} \cup \mathcal{T})^\ast
    \end{equation}
\end{definition}

\begin{definition}[Sentence]
    A \textit{sentence} $\beta$ refers to a string of only \textit{terminals}, usually the last step in a sequence of \textit{derivations}.
    \begin{equation}
        \beta = \mathcal{T}^\ast
    \end{equation}
\end{definition}

\subsection{Parse Trees}

\begin{definition}[Parse Tree]
    A \textit{parse tree} illustrates a \textit{derivation}.
    \begin{enumerate}
        \item Start symbol $S$ is the \textit{root} of the tree.
        \item For production $X \to Y_1 \cdots Y_n$, create a \textit{node} with \textit{key} $X$ and \textit{children} $Y_1, \dots, Y_n$.
    \end{enumerate}
    
    \begin{figure}[H]
        \centering
        \begin{forest}
            for tree={
                draw=black,
                edge={->},
                edge from parent/.style={draw=black}
            }
            [$S$
                [$X$
                    [$Y_1$]
                    [$\dots$]
                    [$Y_n$]
                ]
            ]
        \end{forest}
        \caption{Generic Parse Tree. Note root $S$ is the start symbol and $X$ is an interior node of $S$ with children $Y_1, \dots, Y_n$.}
        \label{fig:generic-parse-tree}
    \end{figure}
\end{definition}

\begin{remark}
    A \textit{parse tree} corresponds with a \textit{Context-Free Grammar} by having
    \begin{itemize}
        \item Terminals as \textit{leaves}.
        \item Non-terminals as \textit{interior nodes}.
    \end{itemize}
    
    \begin{figure}[H]
        \centering
        \begin{forest}
            for tree={
                draw=black,
                edge={->},
                edge from parent/.style={draw=black}
            }
            [$S$
                [$\dots$
                    [$\mathcal{N}$
                        [$\mathcal{T}$]
                        [$\dots$]
                        [$\mathcal{T}$]
                    ]
                ]
            ]
        \end{forest}
        \caption{Parse tree correspondence with CFG}
        \label{fig:parse-tree-and-cfg}
    \end{figure}
    
    \begin{itemize}
        \item An \textit{in-order traversal} of the \textit{parse tree} yields the original input string.
        \item The \textit{parse tree} contains the \textit{association} of \textit{operations} for which the input string does not.
    \end{itemize}
\end{remark}

\subsection{Left-most and Right-most Derivations}

\begin{definition}[Left-most Derivation]
    The \textit{left-most derivation} occurs when the \textit{left-most non-terminal} is always expanded.
\end{definition}

\begin{definition}[Right-most Derivation]
    The \textit{right-most derivation} occurs when the \textit{right-most non-terminal} is always expanded.
\end{definition}

\begin{example}
    For a very simple grammar for addition and subtraction expressions
    \begin{equation*}
        \begin{matrix}
            S &\to  & E + E \\
              &\mid & E - E \\
              &\mid & E \\
            E &\to  & a \\
              &\mid & b \\
        \end{matrix}
    \end{equation*}
    
    This grammar is \textit{ambiguous} because two parse trees can be produced for the input string
    \begin{equation*}
        a + b - a
    \end{equation*}
    
    \begin{figure}[H]
        \centering
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{forest}
                for tree={
                    draw=black,
                    edge={->},
                    if n children=0{tier=terminal}{},
                    s sep=10pt,
                },
                [$A$
                    [$A$
                        [$a$]
                    ]
                    [$+$]
                    [$A$
                        [$A$
                            [$b$]
                        ]
                        [$-$]
                        [$A$
                            [$a$]
                        ]
                    ]
                ]
            \end{forest}
            \caption{Left-most derivation}
        \end{subfigure}
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{forest}
                for tree={
                    draw=black,
                    edge={->},
                    if n children=0{tier=terminal}{},
                    s sep=10pt,
                },
                [$A$
                    [$A$
                        [$A$
                            [$a$]
                        ]
                        [$+$]
                        [$A$
                            [$b$]
                        ]
                    ]
                    [$-$]
                    [$A$
                        [$a$]
                    ]
                ]
            \end{forest}
            \caption{Right-most derivation}
        \end{subfigure}
        \caption{Ambiguous grammar with multiple valid parse trees}
        \label{fig:left-most-right-most-ambiguous-grammar}
    \end{figure}
    
    When the \textit{left-most} and \textit{right-most} derivations both produce the \textit{same} parse tree, then the grammar is \textit{unambiguous}.
\end{example}

\subsection{Chomsky Hierarchy}

\begin{definition}[Chomsky Hierarchy]
    The \textit{Chomsky Hierarchy} classifies different languages in increasing expressive power.
    
    \begin{figure}[H]
        \centering
        \begin{tabularx}{\textwidth}{@{} X X X X @{}}
            \toprule
            Expressiveness & Grammar & Production Constraint & Automata \\
            \midrule
            $\uparrow$ & Universal & $\alpha \to \beta$ & Turing \par Machine \\
            \phantom{} & Context-Sensitive & $\alpha A \beta \to \alpha \delta \beta$ & Linear \par Bounded \par Automata \\
            \phantom{} & Context-Free & $A \to \alpha$ & Push-Down \par Automata \\
            $\downarrow$ & Regular (right) & $A \to a \mid aB \mid \epsilon$ & Deterministic \par Finite \par Automata \\
            \bottomrule
        \end{tabularx}
        \caption{Chomsky Hierarchy}
        \label{fig:chomsky-hierarachy}
    \end{figure}
\end{definition}

\subsection{Solutions to Resolve Ambiguity}

\begin{enumerate}
    \item \textbf{Hacking}: Rewrite the grammar to enforce the precedence.
    \begin{example}
        Simple grammar solution
        \begin{equation*}
            \begin{matrix}
                E &\to  & E + E \\
                  &\mid & E * E \\
                  &\mid & ( E ) \\
                  &\mid & id \\
             \end{matrix}
        \end{equation*}
        converting to 
        \begin{equation*}
            \begin{matrix}
                E &\to  & E' + E \\
                  &\mid & E' \\
                  \\
                E'&\to  & (E) * E'\\
                  &\mid & (E) \\
                  &\mid & id * E' \\
                  &\mid & id \\
             \end{matrix}
        \end{equation*}
    \end{example}
    \item \textbf{Unambiguous annotations}: \\
    Using natural grammar but along with forced annotations (for example, precedence).
    
    \begin{example} A simple example\\
    
        \begin{BVerbatim}
        left  + 
        right * 
        \end{BVerbatim}
    \end{example}
    
    Where \\
    
    \begin{BVerbatim}
    %left  -->  left associative
    %right -->  right associative
    \end{BVerbatim}
        
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node [phantomblock] (pre) {Precedence};
            \node [phantomblock, right=0.3em of pre] (rm) {};
            \node [block, above=0.5em of rm] (rt) {Last rule};
            \node [block, below=0.5em of rm] (rb) {First rule};
            \draw [->] (rb) -- (rt);
        \end{tikzpicture}
    \end{figure}
\end{enumerate}


